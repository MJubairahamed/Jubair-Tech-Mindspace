### **Key Annotations in Spring Boot and Their Usage**  

**important Spring Boot annotations** and their **usage**:  

| **Annotation** | **Usage** | **Example** |
|--------------|----------|------------|
| `@SpringBootApplication` | Marks the main application class and enables auto-configuration. | `@SpringBootApplication public class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } }` |
| `@Component` | It is the generic stereotype annotation that marks a class as a Spring-managed component. It's the parent annotation that `@Service` and `@Repository` inherit from. Use this when a class doesn't fit into any specialized category. | `@Component public class MyComponent { }` |
| `@Service` | Marks a **service layer** class (business logic). It indicates that a class performs business logic or calculations. It's functionally identical to `@Component` but communicates to developers that this class contains service-layer logic like transaction management, validation, or orchestration of multiple repositories| `@Service public class UserService { }` |
| `@Repository` | Marks a **DAO (Data Access Object)** class and enables exception translation. It is designates a class that interacts with a database or other data store.Exception translation: Automatically converts persistence-specific exceptions into Spring's unified DataAccessException hierarchy. | `@Repository public class UserRepository { }` |
| `@Controller` | Marks a **Spring MVC controller** (for returning views). | `@Controller public class HomeController { @GetMapping("/") public String home() { return "index"; } }` |
| `@RestController` | A combination of `@Controller` and `@ResponseBody` for REST APIs. | `@RestController public class UserController { @GetMapping("/users") public List<User> getUsers() { return userService.getAllUsers(); } }` |
| `@RequestMapping` | Maps HTTP requests to a controller method (supports all HTTP methods). | `@RequestMapping("/users") public class UserController { }` |
| `@GetMapping` | Handles **HTTP GET** requests. | `@GetMapping("/{id}") public User getUser(@PathVariable int id) { return userService.getUser(id); }` |
| `@PostMapping` | Handles **HTTP POST** requests. | `@PostMapping("/") public void createUser(@RequestBody User user) { userService.createUser(user); }` |
| `@PutMapping` | Handles **HTTP PUT** requests (update resource). | `@PutMapping("/{id}") public void updateUser(@PathVariable int id, @RequestBody User user) { userService.updateUser(id, user); }` |
| `@DeleteMapping` | Handles **HTTP DELETE** requests. | `@DeleteMapping("/{id}") public void deleteUser(@PathVariable int id) { userService.deleteUser(id); }` |
| `@PathVariable` | Extracts a value from the URL. | `@GetMapping("/{id}") public User getUser(@PathVariable int id) { return userService.getUser(id); }` |
| `@RequestParam` | Extracts query parameters from the request. | `@GetMapping("/users") public List<User> getUsers(@RequestParam String name) { return userService.findByName(name); }` |
| `@RequestBody` | Maps request body to a Java object (for JSON data). | `@PostMapping("/") public void createUser(@RequestBody User user) { }` |
| `@ResponseBody` | Converts Java object to JSON response. | `@ResponseBody public User getUser() { return new User(1, "John"); }` |
| `@Autowired` | Injects a Spring bean automatically. | `@Service public class UserService { @Autowired private UserRepository userRepository; }` |
| `@Qualifier` | Resolves conflicts when multiple beans of the same type exist. It allows you to specify a specific bean to be injected by using a qualifier value.| `interface Message {} @Component("email") class Email implements Message {} @Component("sms") class SMS implements Message {} @Service class MessageService { @Autowired @Qualifier("email")  private Message message; }` Note: In this example, the **MessageService** depends on the Message interface. There are two implementations of this interface: Email and SMS. Without the **@Qualifier** annotation, Spring would not know which bean to inject. By using **@Qualifier("email")**, we specify that the email bean should be injected.|
| `@Primary` | The `@Primary` annotation is used to indicate a default bean when multiple beans of the same type are present. If multiple beans are eligible for autowiring and none of them are explicitly specified using @Qualifier, the bean marked with @Primary will be selected by default. | `@Primary @Component public class PrimaryBean { }` |
| `@Value` | Injects values from properties files. | `@Value("${app.name}") private String appName;` |
| `@Configuration` | Marks a class as a **Spring configuration class**. | `@Configuration public class AppConfig { @Bean public RestTemplate restTemplate() { return new RestTemplate(); } }` |
| `@Bean` | Declares a Spring bean explicitly inside a `@Configuration` class. | `@Bean public RestTemplate restTemplate() { return new RestTemplate(); }` |
| `@ComponentScan` | Tells Spring to scan a package for components. | `@ComponentScan("com.example")` |
| `@EnableAutoConfiguration` | Enables automatic Spring Boot configuration. | `@EnableAutoConfiguration` |
| `@Transactional` | Ensures that a method runs within a transaction. | `@Transactional public void transferMoney() { debitAccount(); creditAccount(); }` |
| `@Cacheable` | The `@Cacheable` annotation in Spring is used to enable caching for a method. When a method annotated with `@Cacheable` is called, Spring checks if the result of the method call is already cached. If it is, Spring returns the cached result instead of executing the method again. If it is not cached, the method is executed, and the result is stored in the cache before being returned. This can significantly **improve the performance of applications** by reducing the number of times expensive operations, such as database queries or API calls, need to be performed.To use `@Cacheable`, you need to first enable caching in your Spring application using the `@EnableCaching` annotation. Then, you can annotate the methods you want to cache with @Cacheable | `@Service @EnableCaching public class MyService { @Cacheable("myCache") public String getData(String key) {   return data;    } }` |
| `@Scheduled` | `@Scheduled` is an annotation used to schedule the execution of methods at specific times or   ntervals. It's a part of Spring's task scheduling capabilities, allowing developers to automate tasks within their applications. To use `@Scheduled`, it's necessary to enable scheduling in the Spring configuration, typically by using the `@EnableScheduling` annotation.`@Scheduled` annotation offers several attributes to define the scheduling behavior:`fixedDelay`,`fixedRate`,`Corn`  | `@Scheduled(fixedRate = 5000) public void logTime() { System.out.println(new Date()); }` |
| `@Async` | The `@Async` annotation is used to indicate that a method should be executed asynchronously in a separate thread. This allows the calling thread to continue its execution without waiting for the completion of the annotated method. It's particularly useful for long-running tasks or operations that don't require immediate results, improving application responsiveness and performance. To use `@Async`, you need to: Enable asynchronous processing by adding `@EnableAsync` to your Spring configuration class. The return type of an `@Async` method can be either `void` or `Future<?>`| `@Async public void sendEmail() { // Asynchronous email sending logic }` |
| `@PreAuthorize` | Applies method-level security based on roles.If the conditions are not met, an `AccessDeniedException` is thrown, and the method is not executed. To use `@PreAuthorize`, you first need to enable method security in your Spring configuration. This can be done by adding the `@EnableGlobalMethodSecurity(prePostEnabled = true)` annotation to a configuration class.| `@PreAuthorize("hasRole('ADMIN')") public void deleteUser() { }` |

---
 
