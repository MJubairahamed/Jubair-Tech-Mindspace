
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AngularFAQ</title>
   <style>
       body { font-family: sans-serif; max-width: 800px; margin: auto; padding: 2rem; background: #f9f9f9; }
       h1, h2, h3 { color: #2c3e50; }
       pre { background: #eee; padding: 1rem; overflow-x: auto; }
       code { color: #d63384; }
   </style>  
</head>
<body>
  <h1>Angular FAQ's</h1>
<h3><strong>Difference between Promise and Observables in angular</strong></h3>
<ul>
<li>In Angular (and JavaScript/TypeScript in general), <strong>Promises</strong> and <strong>Observables</strong> are both used for handling asynchronous operationsâ€”but they differ significantly in terms of functionality, flexibility, and use cases. Here's a clear comparison:</li>
</ul>
<table>
<thead>
<tr>
<th>Feature</th>
<th><strong>Promise</strong></th>
<th><strong>Observable</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Library</td>
<td>Built-in JavaScript (ES6)</td>
<td>Provided by RxJS (used in Angular)</td>
</tr>
<tr>
<td>Value Emission</td>
<td>Emits a <strong>single</strong> value</td>
<td>Emits <strong>multiple</strong> values over time</td>
</tr>
<tr>
<td>Execution</td>
<td>Executes immediately when created</td>
<td>Executes only when subscribed</td>
</tr>
<tr>
<td>Cancellability</td>
<td>Cannot be cancelled</td>
<td>Can be cancelled using <code>unsubscribe()</code></td>
</tr>
<tr>
<td>Operators</td>
<td>Limited (<code>then</code>, <code>catch</code>)</td>
<td>Rich set of RxJS operators (<code>map</code>, <code>filter</code>, <code>retry</code>, etc.)</td>
</tr>
<tr>
<td>Laziness</td>
<td>Eager (starts right away)</td>
<td>Lazy (starts on subscription)</td>
</tr>
<tr>
<td>Error Handling</td>
<td><code>.catch()</code> handles errors</td>
<td>Powerful error handling via RxJS (<code>catchError</code>, <code>retry</code>, etc.)</td>
</tr>
<tr>
<td>Use Case</td>
<td>Suitable for one-time async tasks like HTTP requests</td>
<td>Ideal for streams, event handling, real-time data</td>
</tr>
<tr>
<td>Composition</td>
<td>Limited chaining</td>
<td>Advanced chaining and transformation using operators</td>
</tr>
</tbody>
</table>
<h3>Example</h3>
<p><strong>Promise:</strong></p>
<pre><code class="language-typescript">getData(): Promise&lt;any&gt; {
  return fetch('api/data').then(res =&gt; res.json());
}
</code></pre>
<p><strong>Observable (Angular Way):</strong></p>
<pre><code class="language-typescript">getData(): Observable&lt;any&gt; {
  return this.http.get&lt;any&gt;('api/data');
}
</code></pre>
<h3><strong>What is DDependency Injection (DI) in angular?</strong></h3>
<ul>
<li>Dependency Injection (DI) in Angular is a design pattern where a class requests dependencies from external sources rather than creating them itself. It's a core concept in Angular that promotes loose coupling, modularity, and testability.</li>
<li>Instead of a component creating its dependencies, such as services, Angular's DI framework provides these dependencies when the component is instantiated. This is achieved through <strong>injectors and providers</strong>.</li>
<li><strong>Injectors</strong> are responsible for creating and managing dependencies, while <strong>providers</strong> configure how these dependencies are created.</li>
</ul>

</body>
</html>
<style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: auto;
      padding: 2rem;
      background: #f9f9f9;
    }
    h1 {
        color:rgb(5, 7, 9);
        text-align: center;
    }
    h2, h3, h4, h5, h6  {
      color: #2c3e50;
    }
    pre {
      background: #eee;
      padding: 1rem;
      overflow-x: auto;
    }
    code {
      color: #d63384;;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background: white;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.75rem;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
    }
    tr:nth-child(even) td {
      background-color: #f9f9f9;
    }
    tr:hover td {
      background-color: #eef2f7;
    }
  </style>
